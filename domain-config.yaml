authorize:
  sameDomain:
    postgres: same_domain_authorization
  crossDomain:
    postgres: cross_domain_authorization
postgres:
  tables:
    translatable_targets:
      type: application/json;type=translatable_target
      columns:
        source_language: TEXT
        source_string: TEXT
        path: JSONB
    translations:
      type: application/json;type=translation
      columns:
        translatable_target: TEXT
        language: TEXT
        value: TEXT
  functions:
    same_domain_authorization:
      returns: BOOLEAN
      language: PLpgSQL
      body: |
        BEGIN
          RETURN TRUE;
        END;
      arguments:
      - name: requestingUser
        type: TEXT
      - name: requestedScope
        type: TEXT
    cross_domain_authorization:
      returns: BOOLEAN
      language: PLpgSQL
      body: |
        BEGIN
          RETURN TRUE;
        END;
      arguments:
      - name: requestingDomain
        type: TEXT
      - name: requestingUser
        type: TEXT
      - name: requestedScope
        type: TEXT
  queries:
    translatable-items: |
      SELECT DISTINCT (path->0) AS translatable_item
      FROM translatable_targets
      WHERE jsonb_typeof(path) = 'array'
    translation-set:
      domains:
      - f74e9cb3-2b53-4c85-9b0c-f1d61b032b3f.localhost:5888
      - c0f3a481-d4d5-4133-a198-94a325aa4536.localhost:6061
      body: |
        SELECT
          translatable_targets.id as translatable_target,
          translatable_targets.path,
          COALESCE(translations.language, translatable_targets.source_language) AS language,
          COALESCE(translations.value, translatable_targets.source_string) AS value,
          (translations.value IS NULL) AS fallback,
          (translatable_targets.source_language = translations.language) AS source
        FROM translatable_targets
        JOIN metadata target_md ON target_md.id = translatable_targets.id
        LEFT JOIN translations ON translations.translatable_target = translatable_targets.id
          AND translations.language LIKE $2 || '%'
        LEFT JOIN metadata translation_md ON translation_md.id = translations.id
          AND translation_md.owner = $DOMAIN
        WHERE (
            target_md.owner = $REQUESTING_DOMAIN
            OR $REQUESTING_DOMAIN = $DOMAIN
          )
          AND translatable_targets.path->0 = to_jsonb($1::text)
agent: |
  import Agent from 'npm:@knowlearning/agents/deno.js'

  const TRANSLATION_TYPE = 'application/json;type=translation'

  Agent.on('child', child => {
    const { environment: { user } } = child
    Agent.log(`GOT CHILD CONNECTION!!!!!!!! ${user}`)

    child.on('mutate', async ({ scope, id }) => {
      if (scope.startsWith('translatable_target/')) {
        //  TODO: validate user is a domain agent with rights to access
        const  { source_language, source_string } = await Agent.state(id)
        const translationScope = await getTranslationScope(id, source_language)

        translationScope.translatable_target = id
        translationScope.language = source_language
        translationScope.value = source_string
      }
      else if (scope.startsWith('translations/')) {
        const [,, language] = scope.split('/')

        const paths = await Agent.state(id)

        // TODO: smarter updating based on patch data
        await Promise.all(
          Object
            .entries(paths)
            .map(async ([translatable_target, value]) => {
              const translationScope = await getTranslationScope(translatable_target, language)

              translationScope.translatable_target = translatable_target
              translationScope.language = language
              translationScope.value = value
            })
        )
      }
    })
  })

  async function getTranslationScope(id, lang) {
    const name = `translation/${id}/${lang}`
    const metadata = await Agent.metadata(name)

    if (metadata.active_type !== TRANSLATION_TYPE) metadata.active_type = TRANSLATION_TYPE

    return Agent.state(name)
  }
